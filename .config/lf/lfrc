# Ueberzug setup
set previewer ~/.config/lf/preview
set cleaner ~/.config/lf/cleaner
set preview true

# ===================================================================
# LF Configuration - Translated from Ranger config
# ===================================================================

# ===================================================================
# == Basic Options (Direct translations)
# ===================================================================

# UI Settings
set ratios 1:2:3
# set hiddenfiles "^\.|\.(?:pyc|pyo|bak|swp)$|^lost\+found$|^__(py)?cache__$"
set drawbox false
set scrolloff 8

# Sorting
set sortby ctime; set reverse true
set ignorecase true
set dirfirst true

# ===================================================================
# == Keybindings Translation
# ===================================================================

# Basic navigation (ranger uses hjkl, LF uses arrow keys by default)
# Add hjkl navigation similar to ranger
map k up
map j down
map h updir
map l open

map gh cd ~
map gE cd /etc
map gR cd ~/.config/ranger
map gd cd ~/disk
map gt cd ~/.local/share/Trash
map gT cd ~/.config/tridactyl
map gG cd ~/gdrive
map g4 cd ~/gdrive/Levv/4chan
map gw cd ~/gdrive/Levv/wllpps
map gu cd ~/util
map gL cd ~/gdrive/library/
map gA cd ~/gdrive/library/abstracts
map ga cd ~/adata
map gb cd ~/gdrive/library/books
map gP cd ~/prog
map gc cd ~/.config
map gM cd ~/disk/Musik
map gf cd ~/sandisk/Filmes
map gm cd ~/macrovip
map gD cd ~/Downloads
map gs cd ~/sandisk/sss
map gS cd ~/sandisk

# Page navigation
map <pagedown> down 50%
map <pageup> up 50%
map <C-f> down 50%
map <C-b> up 50%

# File operations
map <delete> delete
map D $ trash -v $fx 2>&1
map <C-e> $ rm -rf $fx
map a rename
map cw rename
map A :rename
map I $ file "$fx"
map i %{{ sxiv -ab -- $(dirname "$f") }}
cmd open $/home/m/.config/lf/opener "$f"

# Yank operations 
cmd yank-path $printf '%s' "$f" | xsel -i -b
cmd yank-name $printf '%s' "$(basename "$f")" | xsel -i -b
cmd yank-bytes %{{ ~/.local/bin/ic "$f" }}

map Yp yank-path
map Yn yank-name
map Yb yank-bytes

# Marking/Selection (LF uses space for toggle)
map <space> toggle

# Search
map | :filter 

map ; set hidden!

# ===================================================================
# == Tabs Support
# ===================================================================

# LF has tab support but different keybindings
map <C-t> tab-new
map <C-w> tab-close
map gn tab-new
map gt tab-next
map gT tab-prev

# ===================================================================
# == Sorting Modes (like ranger's 'o' commands)
# ===================================================================

cmd sort-size  :set sortby size;  set info size
cmd sort-mtime :set sortby time;  set info time
cmd sort-ctime :set sortby ctime; set info ctime
cmd sort-atime :set sortby atime; set info atime
cmd sort-name  :set sortby name;  set info 
cmd sort-ext   :set sortby ext;   set info

cmd shuffle ${{
  batch=""
  count=0
  for f in *; do
    [ -n "$f" ] && {
      if [ -z "$batch" ]; then
        batch="addcustominfo '$f' '$RANDOM'"
      else
        batch="$batch; addcustominfo '$f' '$RANDOM'"
      fi
      count=$((count + 1))
      
      if [ $count -eq 50 ]; then
        lf -remote "send $id $batch"
        batch=""
        count=0
        # sleep 0.001 2>/dev/null || true
      fi
    }
  done
  [ -n "$batch" ] && lf -remote "send $id $batch"
  lf -remote "send $id set sortby custom"
}}

map oz :shuffle

map os :sort-size;  set reverse true
map oS :sort-size;  set reverse false
map om :sort-mtime; set reverse true
map oM :sort-mtime; set reverse false
map oc :sort-ctime; set reverse false
map oC :sort-ctime; set reverse true
map oa :sort-atime; set reverse false
map oA :sort-atime; set reverse true
map on :sort-name;  set reverse false
map oN :sort-name;  set reverse true
map oe :sort-ext;   set reverse false
map oE :sort-ext;   set reverse true

# ===================================================================
# == External Programs Integration
# ===================================================================

# Editor
map e $ sh -c '$EDITOR "$fx"'

# Image viewing/set as wallpaper
map bw $ ~/.local/bin/setbg $fx &

# File operations
# map du $ du -h --max-depth=1 $fx | sort -rh
# map dU $ du -h --max-depth=1 --apparent-size $fx | sort -rh

# Clipboard operations
cmd paste-image $ xsel -i -b -target image/png -o > "$(dirname $fx)/$(date +%s).png"
cmd paste-jpeg $ xsel -i -b -target image/jpeg -o > "$(dirname $fx)/$(date +%s).jpg"
map pB paste-image
map pb paste-jpeg

# ===================================================================
# == Custom Commands
# ===================================================================

cmd file-info $ file $fx | less
map I file-info

# ===================================================================
# == Console/Shell Integration
# ===================================================================

cmd mkdir %{{
    echo "Directory name: "
    read dir
    [ -n "$dir" ] && mkdir -p "$dir"
    lf -remote "send $id reload"
}}
map M mkdir

cmd unzip %{{
    unp -U "$fx"
}}
map U unzip

cmd z ${{
    result="$(zoxide query -i | grep -v "$PWD" | sed 's/\\/\\\\/g;s/"/\\"/g')"
    notify-send $id
    lf -remote "send $id cd \"$result\""
}}
cmd on-cd &{{ zoxide add "$PWD" }}
map z z

map R ${{
    sel=$(mktemp --suffix=.txt)
    # Save original names
    printf '%s\n' "$fx" > "$sel"
    
    # Read original names into array
    oldnames=()
    while IFS= read -r line; do
        oldnames+=("$line")
    done < "$sel"
    
    # Edit the file
    nvim "$sel"
    
    # Read new names into array
    newnames=()
    while IFS= read -r line; do
        newnames+=("$line")
    done < "$sel"
    
    # Check if arrays have same length
    if [ ${#oldnames[@]} -ne ${#newnames[@]} ]; then
        echo "Error: Number of files changed!" >&2
    else
        # Rename files
        for i in "${!oldnames[@]}"; do
            if [ "${oldnames[i]}" != "${newnames[i]}" ]; then
                mv -i -- "${oldnames[i]}" "${newnames[i]}"
            fi
        done
    fi
    
    rm -f "$sel"
}}

# ===================================================================
# == UI Toggles (like ranger's 'z' commands)
# ===================================================================

set incsearch true
set incfilter true
set mouse true
set shellopts "-eu"
set timefmt '2006 Jan _2 15:04:05'
set ifs "\n"
set period 0

# dynamic directory reloads
cmd on-cd &{{
    # Kill previous watcher
    if [ -f /tmp/lf-watcher-$id.pid ]; then
        kill $(cat /tmp/lf-watcher-$id.pid) 2>/dev/null
    fi
    
    # Start new watcher with debounce
    (
        # Use a simple lock to debounce rapid changes
        last_reload=0
        min_interval=0.5  # Minimum seconds between reloads
        
        if type inotifywait >/dev/null 2>&1; then
            inotifywait -m -e modify,create,delete,move . 2>/dev/null | \
                while read; do
                    now=$(date +%s.%N)
                    if (( $(echo "$now - $last_reload >= $min_interval" | bc -l) )); then
                        lf -remote "send $id reload"
                        last_reload=$now
                    fi
                done
        elif type fswatch >/dev/null 2>&1; then
            fswatch -o . 2>/dev/null | \
                while read; do
                    now=$(date +%s.%N)
                    if (( $(echo "$now - $last_reload >= $min_interval" | bc -l) )); then
                        lf -remote "send $id reload"
                        last_reload=$now
                    fi
                done
        fi
    ) &
    
    echo $! > /tmp/lf-watcher-$id.pid
}}

cmd on-cd %{{ echo "$PWD" > /tmp/lf_current_dir }}

cmd on-cd &{{
    export LF_ID="$id"
}}











map <enter> ${{
    # Only for images
    mime=$(file --mime-type -b -- "$fx" 2>/dev/null)
    case "$mime" in
        image/*)
            # Get current directory
            dir="$PWD"
            current="$fx"
            
            # Get files as LF sees them (but we can't use $ft in mapping)
            # So we'll use shell to get files sorted by modification time
            # This captures the state AT THE MOMENT we press enter
            
            # Change to directory
            cd -- "$dir"
            
            # Get image files sorted by modification time (newest first)
            img_files=$(find . -maxdepth 1 -type f -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.bmp" -o -name "*.tiff" -o -name "*.webp" 2>/dev/null | xargs -I {} stat -c "%Y %n" {} | sort -rn | cut -d' ' -f2- | sed 's|^\./||')
            
            # Find current position
            index=0
            counter=0
            for f in $img_files; do
                if [ "$f" = "$(basename -- "$current")" ]; then
                    index=$counter
                    break
                fi
                counter=$((counter + 1))
            done
            
            # Launch sxiv
            if [ -n "$img_files" ]; then
                eval "setsid sxiv -n $index -- $img_files" >/dev/null 2>&1 &
            else
                setsid sxiv -- "$(basename -- "$current")" >/dev/null 2>&1 &
            fi
            ;;
        *)
            # Non-images: use default opener
            ~/.config/lf/opener "$fx"
            ;;
    esac
}}

cmd on-cd %{{
    pane_id="${LF_TMUX_PANE:-default}"
    sync_file="$HOME/.cache/lf/cwd_${pane_id}"
    echo "$PWD" > "$sync_file"
}}

cmd on-quit %{{
    pane_id="${LF_TMUX_PANE:-default}"
    sync_file="$HOME/.cache/lf/cwd_${pane_id}"
    rm -f "$sync_file"
}}
