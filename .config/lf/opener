#!/bin/sh

# Get the absolute path of the current file
file="$1"
[ -z "$file" ] && exit 1

# Get MIME type
mime=$(file --mime-type -Lb -- "$file")

case "$mime" in
    image/*)
        # Get the directory containing the image
        dir=$(dirname -- "$file")
        
        # Change to that directory
        cd -- "$dir" || exit 1
        
        # Get the current file's basename for finding its position
        current_file=$(basename -- "$file")
        
        # We need to get files in the same order LF displays them
        # This is complex because LF doesn't expose its current file list easily
        
        # Approach 1: Use lf's remote command to get current file list
        # (This requires lf to be running with server mode)
        
        # Approach 2: Simulate LF's sorting in the shell
        # Let's try to replicate the sorting from your lfrc:
        # set sortby ctime; set reverse true
        
        # Get image files, sorted by ctime (newest first due to reverse)
        # Using find to get all images in current directory
        image_files=$(find . -maxdepth 1 -type f \( -iname "*.jpg" -o -iname "*.jpeg" \
            -o -iname "*.png" -o -iname "*.gif" -o -iname "*.bmp" \
            -o -iname "*.tiff" -o -iname "*.webp" \) -exec stat -c "%Y %n" {} \; | \
            sort -rn | cut -d' ' -f2- | sed 's|^\./||')
        
        # If no images found via extension, try MIME type detection
        if [ -z "$image_files" ]; then
            image_files=""
            for f in *; do
                if [ -f "$f" ]; then
                    file_mime=$(file --mime-type -b -- "$f" 2>/dev/null)
                    case "$file_mime" in
                        image/*)
                            # Get ctime for sorting
                            ctime=$(stat -c "%Y" -- "$f" 2>/dev/null || echo "0")
                            image_files="${image_files}${ctime} ${f}\n"
                            ;;
                    esac
                fi
            done
            image_files=$(printf "%b" "$image_files" | sort -rn | cut -d' ' -f2-)
        fi
        
        # Find the position of current file
        index=0
        found=0
        OLDIFS=$IFS
        IFS='
'
        for img in $image_files; do
            if [ "$img" = "$current_file" ]; then
                found=1
                break
            fi
            index=$((index + 1))
        done
        IFS=$OLDIFS
        
        # If we found the file, start sxiv at its position
        if [ $found -eq 1 ]; then
            # Convert list to array for sxiv
            img_array=""
            for img in $image_files; do
                img_array="$img_array \"$img\""
            done
            
            # Launch sxiv with all images, starting at current position
            eval "setsid sxiv -n $index -- $img_array" >/dev/null 2>&1 &
        else
            # Fallback: just open the single file
            setsid sxiv -- "$current_file" >/dev/null 2>&1 &
        fi
        ;;
    
    video/*|audio/*)
        setsid mpv -- "$file" >/dev/null 2>&1 &
        ;;
    
    application/pdf|application/epub+zip)
        setsid zathura -- "$file" >/dev/null 2>&1 &
        ;;
    
    text/*)
        exec "${VISUAL:-${EDITOR:-vi}}" -- "$file"
        ;;
    
    application/zip|application/x-tar|application/x-7z-compressed|application/x-rar)
        atool --list -- "$file" | ${PAGER:-less}
        ;;
    
    *)
        setsid xdg-open -- "$file" >/dev/null 2>&1 &
        ;;
esac
