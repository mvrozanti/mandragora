#!/bin/bash
set -euo pipefail

if [ "$#" -lt 2 ]; then
    echo "Usage: $0 <process_name> <command_to_run> [args...]"
    exit 1
fi

process_name="$1"
shift
command_to_run=("$@")

echo "=== Waiting for '$process_name' ==="
echo ""

# Method 1: Try pidof first (safest, doesn't match command line)
wait_with_pidof() {
    echo "Using exact process name matching..."
    while true; do
        pids=$(pidof "$process_name" 2>/dev/null || true)
        if [ -z "$pids" ]; then
            return 0
        fi
        echo -ne "\rWaiting for $(echo $pids | wc -w) process(es)... "
        sleep 1
    done
}

# Method 2: Fallback to checking /proc (no grep processes)
wait_with_proc() {
    echo "Checking /proc for processes..."
    while true; do
        found=0
        for pid in /proc/[0-9]*/; do
            pid=${pid%/}
            pid=${pid##*/}
            
            # Skip our own PID
            [ "$pid" -eq $$ ] && continue
            
            # Check cmdline
            if [ -f "/proc/$pid/cmdline" ]; then
                cmdline=$(cat "/proc/$pid/cmdline" 2>/dev/null | tr '\0' ' ')
                if [[ "$cmdline" == *"$process_name"* ]]; then
                    found=1
                    break
                fi
            fi
        done
        
        if [ "$found" -eq 0 ]; then
            return 0
        fi
        
        echo -ne "\rProcess still running... "
        sleep 1
    done
}

# Try pidof first, fallback to /proc method
if ! wait_with_pidof; then
    wait_with_proc
fi

echo ""
echo "âœ… All processes finished!"
echo ""
echo "=== Running: ${command_to_run[*]} ==="
"${command_to_run[@]}"
